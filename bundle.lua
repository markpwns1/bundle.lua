-- generated with bundle.lua
-- IGUANA <3 YAK
-- 2023-12-19 18:43:32

local __modules = {}
local function require(module_name) local module = __modules[module_name] if module then return module() else error("module not found: " .. module_name, 2) end end

-- Module "src.path" from src/path.lua
__modules["src.path"] = function(...) local path = {} function path.fill_path_template(path, file) return path:gsub("%?", file) end function path.dot_to_slash(module_name) return module_name:gsub("%.", "/") end function path.normalise_slashes(path) return path:gsub("\\", "/") end function path.open_module_file(include_paths, module_name) local module_path = path.dot_to_slash(module_name) for _, include_path in ipairs(include_paths) do local full_path = path.normalise_slashes(path.fill_path_template(include_path, module_path)) local file = io.open(full_path, "r") if file then return file, full_path end end return nil end function path.get_filename(path) local filename = path:match("[^/]*$") return filename:match("(.+)%..+") or filename end return path end

-- Module "src.bundle" from src/bundle.lua
__modules["src.bundle"] = function(...) local path = require("src.path") local generate_animal_hash = require("src.animal-hash") local settings = {} local function char_at(str, i) if i > #str then return "" end return str:sub(i, i) end local function process_file(f) local contents = "" local original_contents = "" local search_depth = 0 local search_start = "" local searching_for = "" local preserve_original_content = false local first_line = true local explore = true local last_char_was_space = false local require_indices = {} local function write(str) if not preserve_original_content and str == " " then if not last_char_was_space then contents = contents .. " " last_char_was_space = true end else contents = contents .. str last_char_was_space = false end end for line in f:lines() do if not line:match("^%s*%-%-") and not line:match("^%s*$") then original_contents = original_contents .. "    " .. line .. "\n" end if first_line then if line == "-- generated with bundle.lua" then explore = false end first_line = false elseif search_depth > 0 and preserve_original_content then write("\n") end local i = 1 write(" ") while i <= #line do local function skip_to_end_of_line() i = #line + 1 end local function is_multiline_string_start() local j = i if char_at(line, i) == "[" then local start = "[" local search = "]" i = i + 1 while char_at(line, i) == "=" do start = start .. "=" search = search .. "=" i = i + 1 end if char_at(line, i) == "[" then return true, start .. "[", search .. "]" else i = j return false end else return false end end local function scan_string() local j = i local search = char_at(line, i) i = i + 1 while char_at(line, i) ~= search do if char_at(line, i) == "\\" then i = i + 1 end i = i + 1 end i = i + 1 return line:sub(j + 1, i - 2) end local started_at = i if search_depth > 0 then if line:sub(i, i + #searching_for - 1) == searching_for then search_depth = search_depth - 1 i = i + #searching_for if preserve_original_content then write(searching_for) end elseif line:sub(i, i + #search_start - 1) == search_start then search_depth = search_depth + 1 i = i + #search_start if preserve_original_content then write(search_start) end elseif preserve_original_content then write(char_at(line, i)) i = i + 1 else i = i + 1 end else local c = char_at(line, i) if c == "-" and char_at(line, i + 1) == "-" then if char_at(line, i + 2) == "[" then local start = "[" local search = "]" i = i + 3 while char_at(line, i) == "=" do start = start .. "=" search = search .. "=" i = i + 1 end if char_at(line, i) == "[" then search_depth = 1 preserve_original_content = false search_start = start .. "[" searching_for = search .. "]" else skip_to_end_of_line() end else skip_to_end_of_line() end elseif c == "\"" or c == "'" then local inner = scan_string() write(c .. inner .. c) elseif c == " " or c == "\t" then while char_at(line, i) == " " or char_at(line, i) == "\t" do i = i + 1 end if not last_char_was_space then write(" ") last_char_was_space = true end else local is_multiline_string, start, search = is_multiline_string_start() if is_multiline_string then write(start) i = i + #search search_depth = 1 preserve_original_content = true search_start = start searching_for = search else if line:sub(i, i + 6) == "require" then table.insert(require_indices, #contents + 1) end write(c) i = i + 1 end end end end end local requires = {} if explore then for _, i in ipairs(require_indices) do i = i + 8 local function skip_whitespace() while char_at(contents, i) == " " or char_at(contents, i) == "\t" do i = i + 1 end end if i <= #contents then skip_whitespace() local bracket_depth = 0 while char_at(contents, i) == "(" do bracket_depth = bracket_depth + 1 i = i + 1 end skip_whitespace() if char_at(contents, i) == "\"" or char_at(contents, i) == "'" then local j = i local search = char_at(contents, i) i = i + 1 while char_at(contents, i) ~= search do if char_at(contents, i) == "\\" then i = i + 1 end i = i + 1 end local path if char_at(contents, i) == search then i = i + 1 path = contents:sub(j + 1, i - 2) end skip_whitespace() local valid = true for k = 1, bracket_depth do if char_at(contents, i) ~= ")" then valid = false break end i = i + 1 end if valid then table.insert(requires, path) end end end end end if not settings.minify then contents = original_contents end return { minified = contents, requires = requires } end local function array_contains(arr, val) for _, v in ipairs(arr) do if v == val then return true end end return false end local modules = {} local function explore_requires(requires) for _, module in ipairs(requires) do if not modules[module] and not array_contains(settings.ignore_modules, module) then local file, full_path = path.open_module_file(settings.include_paths, module) if file then local processed = process_file(file) file:close() modules[module] = { content = processed.minified, path = full_path } explore_requires(processed.requires) else print("WARNING: module '" .. module .. "' not found", 1) end end end end local function bundle(entry_file, s) modules = {} s.ignore_modules = s.ignore_modules or {} settings = s local entry_file_handle = io.open(entry_file, "r") local entry_file_info = process_file(entry_file_handle) entry_file_handle:close() explore_requires(entry_file_info.requires) local output = "" local function write(str) output = output .. str end write("-- generated with bundle.lua\n") write("-- " .. generate_animal_hash() .. "\n") write("-- " .. os.date("%Y-%m-%d %H:%M:%S") .. "\n\n") write("local __modules = {}\n") write("local function require(module_name) local module = __modules[module_name] if module then return module() else error(\"module not found: \" .. module_name, 2) end end\n") write("\n") for module_name, mod in pairs(modules) do write("-- Module \"" .. module_name .. "\" from " .. mod.path .. "\n") write("__modules[\"" .. module_name .. "\"] = function(...)") if not settings.minify then write("\n") end write(mod.content) if settings.minify then write(" ") end write("end\n") write("\n") end write("-- Entry file \"" .. entry_file .. "\"\n") write("do") if not settings.minify then write("\n") end write(entry_file_info.minified) if settings.minify then write(" ") end write("end\n") return output end return bundle end

-- Module "src.cmd-parse" from src/cmd-parse.lua
__modules["src.cmd-parse"] = function(...) local path = require("src.path") local function parse_args(args) if #args < 1 then print("Usage: lua bundle.lua <entry file> [ options... ]") print("Options:") print("    -i <include path>        Sets the include paths to search for modules") print("                             * Note that the argument must be in the form of ") print("                               \"path/to/include/?.lua;another/path/?.lua\"") print("    -o <output file>         Sets the output file name") print("    -m, --minify             Minifies the output file") print("    -a, --no-animals         Disables animal hashing") print("    -g, --ignore <modules>   Sets the modules to ignore when bundling, separated by semicolons") os.exit(1) end local entry_file = args[1] local include_paths = {} local output_file = path.get_filename(entry_file) .. "_bundle.lua" local minify = false local animal_hash = true local ignore_modules = {} for i = 2, #args do if args[i] == "-i" then i = i + 1 for path in args[i]:gmatch("[^;]+") do table.insert(include_paths, path) end elseif args[i] == "-o" then i = i + 1 output_file = args[i] elseif args[i] == "--minify" or args[i] == "-m" then minify = true elseif args[i] == "--no-animals" or args[i] == "-a" then animal_hash = false elseif args[i] == "--ignore" or args[i] == "-g" then i = i + 1 for path in args[i]:gmatch("[^;]+") do table.insert(ignore_modules, path) end end end return { entry_file = entry_file, include_paths = include_paths, output_file = output_file, minify = minify, animal_hash = animal_hash, ignore_modules = ignore_modules } end return parse_args end

-- Module "src.animal-hash" from src/animal-hash.lua
__modules["src.animal-hash"] = function(...) local ALPHABET_ANIMALS = { "AARDVARK", "BEAR", "CAMEL", "DINGO", "ELEPHANT", "FLAMINGO", "GORILLA", "HIPPO", "IGUANA", "JACKAL", "KANGAROO", "LEMUR", "MONKEY", "NARWHAL", "OCTOPUS", "PENGUIN", "QUAIL", "RABBIT", "SNAKE", "TIGER", "UNICORN", "VULTURE", "WHALE", "YAK", "ZEBRA" } local function select_animal(i) return ALPHABET_ANIMALS[math.fmod(i, #ALPHABET_ANIMALS + 1)] or "SANTA CLAUS" end local function generate_animal_hash() return select_animal(os.date("%H") + os.date("%M")) .. " <3 " .. select_animal(os.date("%H") + os.date("%S")) end return generate_animal_hash end

-- Entry file "src/main.lua"
do local bundle = require("src.bundle") if pcall(debug.getlocal, 4, 1) then return bundle else local parse_args = require("src.cmd-parse") local settings = parse_args({...}) local bundled = bundle(settings.entry_file, settings) local output_file = io.open(settings.output_file, "w") output_file:write(bundled) output_file:close() end  end
